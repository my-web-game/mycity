{
  "version": 3,
  "sources": ["../../src/scripts.ts", "../../node_modules/babylonjs-editor-tools/build/src/loading/loader.js", "../../node_modules/babylonjs-editor-tools/build/src/tools/guards.js", "../../node_modules/babylonjs-editor-tools/build/src/decorators/apply.js", "../../node_modules/babylonjs-editor-tools/build/src/tools/sound.js", "../../node_modules/babylonjs-editor-tools/build/src/loading/script.js", "../../node_modules/babylonjs-editor-tools/build/src/loading/physics.js", "../../node_modules/babylonjs-editor-tools/build/src/rendering/vls.js", "../../node_modules/babylonjs-editor-tools/build/src/rendering/ssr.js", "../../node_modules/babylonjs-editor-tools/build/src/rendering/ssao.js", "../../node_modules/babylonjs-editor-tools/build/src/rendering/motion-blur.js", "../../node_modules/babylonjs-editor-tools/build/src/rendering/default-pipeline.js", "../../node_modules/babylonjs-editor-tools/build/src/loading/rendering.js", "../../node_modules/babylonjs-editor-tools/build/src/rendering/tools.js", "../../node_modules/babylonjs-editor-tools/build/src/tools/light.js", "../../node_modules/babylonjs-editor-tools/build/src/loading/sound.js", "../../node_modules/babylonjs-editor-tools/build/src/loading/texture.js", "../../node_modules/babylonjs-editor-tools/build/src/tools/scalar.js", "../../node_modules/babylonjs-editor-tools/build/src/loading/material.js", "../../node_modules/babylonjs-editor-tools/build/src/tools/animation.js", "../../node_modules/babylonjs-editor-tools/build/src/decorators/inspector.js", "../../node_modules/babylonjs-editor-tools/build/src/cinematic/parse.js", "../../node_modules/babylonjs-editor-tools/build/src/cinematic/tools.js", "../../node_modules/babylonjs-editor-tools/build/src/cinematic/generate.js", "../../node_modules/babylonjs-editor-tools/build/src/cinematic/events/apply-impulse.js", "../../src/scripts/box.ts"],
  "sourcesContent": ["\n/**\n * Generated by Babylon.js Editor\n */\n\nimport { loadScene } from \"babylonjs-editor-tools\";\nimport * as scripts_box from \"./scripts/box\";\n\nexport const scriptsMap = {\n    \"scripts/box.ts\": scripts_box\n};\n\nexport { loadScene };\n", "import { Vector3 } from \"babylonjs\";\nimport { Constants } from \"babylonjs\";\nimport { AppendSceneAsync } from \"babylonjs\";\nimport { SceneLoaderFlags } from \"babylonjs\";\nimport { isMesh } from \"../tools/guards\";\nimport { _applyScriptsForObject } from \"./script\";\nimport { configurePhysicsAggregate } from \"./physics\";\nimport { applyRenderingConfigurations } from \"./rendering\";\nimport { applyRenderingConfigurationForCamera } from \"../rendering/tools\";\nimport { configureShadowMapRefreshRate, configureShadowMapRenderListPredicate } from \"../tools/light\";\nimport \"./sound\";\nimport \"./texture\";\nexport async function loadScene(rootUrl, sceneFilename, scene, scriptsMap, options) {\n    scene.loadingQuality = options?.quality ?? \"high\";\n    await AppendSceneAsync(`${rootUrl}${sceneFilename}`, scene, {\n        pluginExtension: \".babylon\",\n        onProgress: (event) => {\n            const progress = Math.min((event.loaded / event.total) * 0.5);\n            options?.onProgress?.(progress);\n        },\n    });\n    // Ensure all meshes perform their delay state check\n    if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n        scene.meshes.forEach((m) => isMesh(m) && m._checkDelayState());\n    }\n    const waitingItemsCount = scene.getWaitingItemsCount();\n    // Wait until scene is ready.\n    while (!scene.isDisposed && (!scene.isReady() || scene.getWaitingItemsCount() > 0)) {\n        await new Promise((resolve) => setTimeout(resolve, 150));\n        const loadedItemsCount = waitingItemsCount - scene.getWaitingItemsCount();\n        if (loadedItemsCount === waitingItemsCount) {\n            scene.textures.forEach((texture) => {\n                if (texture.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\n                    texture.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\n                }\n            });\n        }\n        options?.onProgress?.(0.5 + (loadedItemsCount / waitingItemsCount) * 0.5);\n    }\n    options?.onProgress?.(1);\n    configureShadowMapRenderListPredicate(scene);\n    configureShadowMapRefreshRate(scene);\n    if (scene.metadata?.rendering) {\n        applyRenderingConfigurations(scene, scene.metadata.rendering);\n        if (scene.activeCamera) {\n            applyRenderingConfigurationForCamera(scene.activeCamera, rootUrl);\n        }\n    }\n    if (scene.metadata?.physicsGravity) {\n        scene.getPhysicsEngine()?.setGravity(Vector3.FromArray(scene.metadata?.physicsGravity));\n    }\n    _applyScriptsForObject(scene, scene, scriptsMap, rootUrl);\n    scene.transformNodes.forEach((transformNode) => {\n        _applyScriptsForObject(scene, transformNode, scriptsMap, rootUrl);\n    });\n    scene.meshes.forEach((mesh) => {\n        configurePhysicsAggregate(mesh);\n        _applyScriptsForObject(scene, mesh, scriptsMap, rootUrl);\n    });\n    scene.lights.forEach((light) => {\n        _applyScriptsForObject(scene, light, scriptsMap, rootUrl);\n    });\n    scene.cameras.forEach((camera) => {\n        _applyScriptsForObject(scene, camera, scriptsMap, rootUrl);\n    });\n}\n//# sourceMappingURL=loader.js.map", "/**\n * Returns wether or not the given object is an AbstractMesh.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isAbstractMesh(object) {\n    switch (object.getClassName?.()) {\n        case \"Mesh\":\n        case \"LineMesh\":\n        case \"GroundMesh\":\n        case \"InstancedMesh\":\n            return true;\n    }\n    return false;\n}\n/**\n * Returns wether or not the given object is a Mesh.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isMesh(object) {\n    switch (object.getClassName?.()) {\n        case \"Mesh\":\n        case \"GroundMesh\":\n            return true;\n    }\n    return false;\n}\n/**\n * Returns wether or not the given object is a InstancedMesh.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isInstancedMesh(object) {\n    return object.getClassName?.() === \"InstancedMesh\";\n}\n/**\n * Returns wether or not the given object is a Bone.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isBone(object) {\n    return object.getClassName?.() === \"Bone\";\n}\n/**\n * Returns wether or not the given object is a GroundMesh.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isGroundMesh(object) {\n    return object.getClassName?.() === \"GroundMesh\";\n}\n/**\n * Returns wether or not the given object is a TransformNode.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isTransformNode(object) {\n    return object.getClassName?.() === \"TransformNode\";\n}\n/**\n * Returns wether or not the given object is a Texture.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isTexture(object) {\n    return object?.getClassName?.() === \"Texture\";\n}\n/**\n * Returns wether or not the given object is a Camera.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isCamera(object) {\n    switch (object.getClassName?.()) {\n        case \"Camera\":\n        case \"FreeCamera\":\n        case \"TargetCamera\":\n        case \"EditorCamera\":\n        case \"ArcRotateCamera\":\n        case \"UniversalCamera\":\n            return true;\n    }\n    return false;\n}\n/**\n * Returns wether or not the given object is a FreeCamera.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isFreeCamera(object) {\n    switch (object.getClassName?.()) {\n        case \"FreeCamera\":\n        case \"UniversalCamera\":\n            return true;\n    }\n    return false;\n}\n/**\n * Returns wether or not the given object is a ArcRotateCamera.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isArcRotateCamera(object) {\n    return object.getClassName?.() === \"ArcRotateCamera\";\n}\n/**\n * Returns wether or not the given object is a PointLight.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isPointLight(object) {\n    return object.getClassName?.() === \"PointLight\";\n}\n/**\n * Returns wether or not the given object is a DirectionalLight.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isDirectionalLight(object) {\n    return object.getClassName?.() === \"DirectionalLight\";\n}\n/**\n * Returns wether or not the given object is a SpotLight.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isSpotLight(object) {\n    return object.getClassName?.() === \"SpotLight\";\n}\n/**\n * Returns wether or not the given object is a HemisphericLight.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isHemisphericLight(object) {\n    return object.getClassName?.() === \"HemisphericLight\";\n}\n/**\n * Returns wether or not the given object is a Light.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isLight(object) {\n    switch (object.getClassName?.()) {\n        case \"Light\":\n        case \"PointLight\":\n        case \"SpotLight\":\n        case \"DirectionalLight\":\n        case \"HemisphericLight\":\n            return true;\n    }\n    return false;\n}\n/**\n * Returns wether or not the given object is a Node.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isNode(object) {\n    return isAbstractMesh(object) || isTransformNode(object) || isLight(object) || isCamera(object);\n}\n/**\n * Returns wether or not the given object is a Scene.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isScene(object) {\n    return object.getClassName?.() === \"Scene\";\n}\n/**\n * Returns wether or not the given object is a ParticleSystem.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isParticleSystem(object) {\n    return object.getClassName?.() === \"ParticleSystem\";\n}\n/**\n * Returns wether or not the given object is a GPUParticleSystem.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isGPUParticleSystem(object) {\n    return object.getClassName?.() === \"GPUParticleSystem\";\n}\n/**\n * Returns wether or not the given object is a IParticleSystem.\n * @param object defines the reference to the object to test its class name.\n */\nexport function isAnyParticleSystem(object) {\n    switch (object.getClassName?.()) {\n        case \"ParticleSystem\":\n        case \"GPUParticleSystem\":\n            return true;\n    }\n    return false;\n}\n//# sourceMappingURL=guards.js.map", "import { Color3, Color4 } from \"babylonjs\";\nimport { Texture } from \"babylonjs\";\nimport { Vector2, Vector3 } from \"babylonjs\";\nimport { AdvancedDynamicTexture } from \"babylonjs-gui\";\nimport { getSoundById } from \"../tools/sound\";\nexport function applyDecorators(scene, object, script, instance, rootUrl) {\n    const ctor = instance.constructor;\n    if (!ctor) {\n        return;\n    }\n    // @nodeFromScene\n    ctor._NodesFromScene?.forEach((params) => {\n        instance[params.propertyKey.toString()] = scene.getNodeByName(params.nodeName);\n    });\n    // @nodeFromDescendants\n    ctor._NodesFromDescendants?.forEach((params) => {\n        const descendant = object.getDescendants?.(params.directDescendantsOnly, (node) => node.name === params.nodeName)[0];\n        instance[params.propertyKey.toString()] = descendant ?? null;\n    });\n    // @fromAnimationGroups\n    ctor._AnimationGroups?.forEach((params) => {\n        instance[params.propertyKey.toString()] = scene.getAnimationGroupByName(params.animationGroupName);\n    });\n    // @soundFromScene\n    ctor._SoundsFromScene?.forEach((params) => {\n        const sound = scene.getSoundByName?.(params.soundName);\n        instance[params.propertyKey.toString()] = sound ?? null;\n    });\n    // @guiFromAsset\n    ctor._GuiFromAsset?.forEach(async (params) => {\n        const guiUrl = `${rootUrl}assets/${params.pathInAssets}`;\n        try {\n            const response = await fetch(guiUrl);\n            const data = await response.json();\n            const gui = AdvancedDynamicTexture.CreateFullscreenUI(data.name, true, scene);\n            gui.parseSerializedObject(data.content, false);\n            instance[params.propertyKey.toString()] = gui;\n            params.onGuiCreated?.(instance, gui);\n        }\n        catch (e) {\n            console.error(`Failed to load GUI from asset: ${guiUrl}`);\n            throw e;\n        }\n    });\n    // @fromParticleSystems\n    ctor._ParticleSystemsFromScene?.forEach((params) => {\n        const particleSystem = scene.particleSystems?.find((particleSystem) => {\n            return particleSystem.name === params.particleSystemName;\n        });\n        instance[params.propertyKey.toString()] = particleSystem;\n    });\n    // @visibleAsNumber, @visibleAsBoolean etc.\n    ctor._VisibleInInspector?.forEach((params) => {\n        const propertyKey = params.propertyKey.toString();\n        const attachedScripts = script.values;\n        if (attachedScripts.hasOwnProperty(propertyKey) &&\n            attachedScripts[propertyKey].hasOwnProperty(\"value\")) {\n            const value = attachedScripts[propertyKey].value;\n            switch (params.configuration.type) {\n                case \"number\":\n                case \"boolean\":\n                case \"keymap\":\n                case \"string\":\n                    instance[propertyKey] = value;\n                    break;\n                case \"vector2\":\n                    instance[propertyKey] = Vector2.FromArray(value);\n                    break;\n                case \"vector3\":\n                    instance[propertyKey] = Vector3.FromArray(value);\n                    break;\n                case \"color3\":\n                    instance[propertyKey] = Color3.FromArray(value);\n                    break;\n                case \"color4\":\n                    instance[propertyKey] = Color4.FromArray(value);\n                    break;\n                case \"entity\":\n                    const entityType = params.configuration.entityType;\n                    switch (entityType) {\n                        case \"node\":\n                            instance[propertyKey] = scene.getNodeById(value) ?? null;\n                            break;\n                        case \"animationGroup\":\n                            instance[propertyKey] = scene.getAnimationGroupByName(value) ?? null;\n                            break;\n                        case \"sound\":\n                            instance[propertyKey] = getSoundById(value, scene);\n                            break;\n                        case \"particleSystem\":\n                            instance[propertyKey] = scene.particleSystems?.find((ps) => ps.id === value) ?? null;\n                            break;\n                    }\n                    break;\n                case \"texture\":\n                    if (value) {\n                        instance[propertyKey] = Texture.Parse(value, scene, rootUrl);\n                    }\n                    break;\n            }\n        }\n    });\n}\n//# sourceMappingURL=apply.js.map", "/**\n * Searches for a sound by its id in the scene by traversing all soundtracks.\n * @param id defines the id of the sound to retrieve.\n * @param scene defines the reference to the scene where to find the instantiated sound.\n */\nexport function getSoundById(id, scene) {\n    const soundTracks = scene.soundTracks ?? [];\n    if (!soundTracks.length) {\n        soundTracks.push(scene.mainSoundTrack);\n    }\n    for (let i = 0, len = soundTracks.length; i < len; i++) {\n        const sound = soundTracks[i].soundCollection.find((s) => s.id === id);\n        if (sound) {\n            return sound;\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=sound.js.map", "import { applyDecorators } from \"../decorators/apply\";\nimport { isAnyParticleSystem, isNode, isScene } from \"../tools/guards\";\n/**\n * @internal\n */\nexport function _applyScriptsForObject(scene, object, scriptsMap, rootUrl) {\n    if (!object.metadata) {\n        return;\n    }\n    object.metadata.scripts?.forEach((script) => {\n        if (!script.enabled) {\n            return;\n        }\n        const exports = scriptsMap[script.key];\n        if (!exports) {\n            return;\n        }\n        if (exports.default) {\n            const instance = new exports.default(object);\n            registerScriptInstance(object, instance, script.key);\n            applyDecorators(scene, object, script, instance, rootUrl);\n            if (instance.onStart) {\n                scene.onBeforeRenderObservable.addOnce(() => instance.onStart());\n            }\n            if (instance.onUpdate) {\n                scene.onBeforeRenderObservable.add(() => instance.onUpdate());\n            }\n        }\n        else {\n            if (exports.onStart) {\n                scene.onBeforeRenderObservable.addOnce(() => exports.onStart(object));\n            }\n            if (exports.onUpdate) {\n                scene.onBeforeRenderObservable.add(() => exports.onUpdate(object));\n            }\n        }\n    });\n    object.metadata.scripts = undefined;\n}\nconst scriptsDictionary = new Map();\n/**\n * When a scene is being loaded, scripts that were attached to objects in the scene using the Editor are processed.\n * This function registers the instance of scripts per object in order to retrieve them later.\n * @param object defines the object in the scene on which the script is attached to.\n * @param scriptInstance defines the instance of the script to register.\n * @param key defines the key of the script. This value is used to identify the script.\n */\nexport function registerScriptInstance(object, scriptInstance, key) {\n    const registeredScript = {\n        key,\n        instance: scriptInstance,\n    };\n    if (!scriptsDictionary.has(object)) {\n        scriptsDictionary.set(object, [registeredScript]);\n    }\n    else {\n        scriptsDictionary.get(object).push(registeredScript);\n    }\n    if (isNode(object) || isAnyParticleSystem(object) || isScene(object)) {\n        object.onDisposeObservable.addOnce((() => {\n            scriptsDictionary.delete(object);\n        }));\n    }\n}\n/**\n * Returns all the instances of the script attached to the given object that matches the given class type.\n * The same script can be attached multiple times to the same object. If you ensure that ONLY DISTINCT scripts\n * are attached to the object, you can use `getScriptByClassForObject` which will return the unique instance for the given object.\n * @param object defines the reference to the object where the script to retrieve is attached to.\n * @param classType defines the class of the type to retrieve\n * @example\n * import { IScript, getAllScriptsByClassForObject } from \"babylonjs-editor-tools\";\n *\n * class ScriptClass implements IScript {\n * \tpublic onStart(): void {\n * \t\tconst instances = getAllScriptsByClassForObject(mesh, OtherScriptClass);\n * \t\tinstances.forEach((i) => {\n * \t\t\ti.doSomething();\n * \t\t});\n * \t}\n * }\n *\n * class OtherScriptClass implements IScript {\n * \tpublic doSomething(): void {\n * \t\tconsole.log(\"Doing something!\");\n * \t}\n * }\n */\nexport function getAllScriptsByClassForObject(object, classType) {\n    const data = scriptsDictionary.get(object);\n    const result = data?.filter((s) => s.instance.constructor === classType);\n    return result?.map((r) => r.instance) ?? null;\n}\n/**\n * Returns the instance of the script attached to the given object that matches the given class type.\n * @param object defines the reference to the object where the script to retrieve is attached to.\n * @param classType defines the class of the type to retrieve\n * @example\n * import { IScript, getScriptByClassForObject } from \"babylonjs-editor-tools\";\n *\n * class ScriptClass implements IScript {\n * \tpublic onStart(): void {\n * \t\tconst instance = getScriptByClassForObject(mesh, OtherScriptClass);\n * \t\tinstance.doSomething();\n * \t}\n * }\n *\n * class OtherScriptClass implements IScript {\n * \tpublic doSomething(): void {\n * \t\tconsole.log(\"Doing something!\");\n * \t}\n * }\n */\nexport function getScriptByClassForObject(object, classType) {\n    const result = getAllScriptsByClassForObject(object, classType);\n    return result?.[0] ?? null;\n}\n//# sourceMappingURL=script.js.map", "import { Vector3, Quaternion } from \"babylonjs\";\nimport { PhysicsAggregate } from \"babylonjs\";\nimport { isInstancedMesh, isMesh } from \"../tools/guards\";\n/**\n * Parses and loads the physics aggregate data for the given mesh.\n * @param mesh defines the reference to the mesh object.\n */\nexport function configurePhysicsAggregate(transformNode) {\n    const data = transformNode.metadata?.physicsAggregate;\n    if (!data) {\n        return;\n    }\n    let mesh = undefined;\n    if (isMesh(transformNode)) {\n        mesh = transformNode;\n    }\n    else if (isInstancedMesh(transformNode)) {\n        mesh = transformNode.sourceMesh;\n    }\n    const aggregate = new PhysicsAggregate(transformNode, data.shape.type, {\n        mesh,\n        mass: data.massProperties.mass,\n    });\n    aggregate.body.setMassProperties({\n        mass: data.massProperties.mass,\n        inertia: data.massProperties.inertia ? Vector3.FromArray(data.massProperties.inertia) : undefined,\n        centerOfMass: data.massProperties.centerOfMass ? Vector3.FromArray(data.massProperties.centerOfMass) : undefined,\n        inertiaOrientation: data.massProperties.inertiaOrientation ? Quaternion.FromArray(data.massProperties.inertiaOrientation) : undefined,\n    });\n    aggregate.shape.density = data.shape.density;\n    aggregate.body.setMotionType(data.body.motionType);\n    aggregate.shape.material = data.material;\n    transformNode.physicsAggregate = aggregate;\n    transformNode.metadata.physicsAggregate = undefined;\n}\n//# sourceMappingURL=physics.js.map", "import { Vector3 } from \"babylonjs\";\nimport { Texture } from \"babylonjs\";\nimport { VolumetricLightScatteringPostProcess } from \"babylonjs\";\nimport { isMesh } from \"../tools/guards\";\nlet vlsPostProcess = null;\n/**\n * Defines the configuration of the motion blur post-process per camera.\n */\nexport const vlsPostProcessCameraConfigurations = new Map();\nexport function getVLSPostProcess() {\n    return vlsPostProcess;\n}\n/**\n * Sets the reference to the volumetric light scattering post-process.\n * @access editor only.\n */\nexport function setVLSPostProcessRef(postProcess) {\n    vlsPostProcess = postProcess;\n}\nexport function disposeVLSPostProcess(scene) {\n    if (vlsPostProcess && scene.activeCamera) {\n        vlsPostProcess.dispose(scene.activeCamera);\n        vlsPostProcess = null;\n    }\n}\nexport function createVLSPostProcess(scene, mesh) {\n    mesh ??= scene.meshes.find((mesh) => isMesh(mesh));\n    vlsPostProcess = new VolumetricLightScatteringPostProcess(\"VolumetricLightScatteringPostProcess\", 1.0, scene.activeCamera, mesh, 100, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n    return vlsPostProcess;\n}\nexport function serializeVLSPostProcess() {\n    if (!vlsPostProcess) {\n        return null;\n    }\n    return {\n        meshId: vlsPostProcess.mesh?.id,\n        exposure: vlsPostProcess.exposure,\n        decay: vlsPostProcess.decay,\n        weight: vlsPostProcess.weight,\n        density: vlsPostProcess.density,\n        invert: vlsPostProcess.invert,\n        useCustomMeshPosition: vlsPostProcess.useCustomMeshPosition,\n        customMeshPosition: vlsPostProcess.customMeshPosition.asArray(),\n    };\n}\nexport function parseVLSPostProcess(scene, data) {\n    let mesh = null;\n    if (data.meshId) {\n        const result = scene.getMeshById(data.meshId);\n        if (result && isMesh(result)) {\n            mesh = result;\n        }\n    }\n    const vlsPostProcess = createVLSPostProcess(scene, mesh);\n    vlsPostProcess.exposure = data.exposure;\n    vlsPostProcess.decay = data.decay;\n    vlsPostProcess.weight = data.weight;\n    vlsPostProcess.density = data.density;\n    vlsPostProcess.invert = data.invert;\n    vlsPostProcess.useCustomMeshPosition = data.useCustomMeshPosition;\n    vlsPostProcess.customMeshPosition.copyFrom(Vector3.FromArray(data.customMeshPosition));\n    return vlsPostProcess;\n}\n//# sourceMappingURL=vls.js.map", "import { SSRRenderingPipeline } from \"babylonjs\";\nlet ssrRenderingPipeline = null;\n/**\n * Defines the configuration of the ssr rendering pipeline per camera.\n */\nexport const ssrRenderingPipelineCameraConfigurations = new Map();\nexport function getSSRRenderingPipeline() {\n    return ssrRenderingPipeline;\n}\n/**\n * Sets the reference to the ssr rendering pipeline.\n * @access editor only.\n */\nexport function setSSRRenderingPipelineRef(pipeline) {\n    ssrRenderingPipeline = pipeline;\n}\nexport function disposeSSRRenderingPipeline() {\n    if (ssrRenderingPipeline) {\n        ssrRenderingPipeline.dispose();\n        ssrRenderingPipeline = null;\n    }\n}\nexport function createSSRRenderingPipeline(scene, camera) {\n    ssrRenderingPipeline = new SSRRenderingPipeline(\"SSRRenderingPipeline\", scene, [camera]);\n    ssrRenderingPipeline.samples = 4;\n    return ssrRenderingPipeline;\n}\nexport function serializeSSRRenderingPipeline() {\n    if (!ssrRenderingPipeline) {\n        return null;\n    }\n    return {\n        samples: ssrRenderingPipeline.samples,\n        step: ssrRenderingPipeline.step,\n        thickness: ssrRenderingPipeline.thickness,\n        strength: ssrRenderingPipeline.strength,\n        reflectionSpecularFalloffExponent: ssrRenderingPipeline.reflectionSpecularFalloffExponent,\n        maxSteps: ssrRenderingPipeline.maxSteps,\n        maxDistance: ssrRenderingPipeline.maxDistance,\n        roughnessFactor: ssrRenderingPipeline.roughnessFactor,\n        reflectivityThreshold: ssrRenderingPipeline.reflectivityThreshold,\n        blurDispersionStrehgth: ssrRenderingPipeline.blurDispersionStrength,\n        clipToFrustum: ssrRenderingPipeline.clipToFrustum,\n        enableSmoothReflections: ssrRenderingPipeline.enableSmoothReflections,\n        enableAutomaticThicknessComputation: ssrRenderingPipeline.enableAutomaticThicknessComputation,\n        attenuateFacingCamera: ssrRenderingPipeline.attenuateFacingCamera,\n        attenuateScreenBorders: ssrRenderingPipeline.attenuateScreenBorders,\n        attenuateIntersectionDistance: ssrRenderingPipeline.attenuateIntersectionDistance,\n        attenuateBackfaceReflection: ssrRenderingPipeline.attenuateBackfaceReflection,\n        blurDownsample: ssrRenderingPipeline.blurDownsample,\n        selfCollisionNumSkip: ssrRenderingPipeline.selfCollisionNumSkip,\n        ssrDownsample: ssrRenderingPipeline.ssrDownsample,\n        backfaceDepthTextureDownsample: ssrRenderingPipeline.backfaceDepthTextureDownsample,\n    };\n}\nexport function parseSSRRenderingPipeline(scene, camera, data) {\n    if (ssrRenderingPipeline) {\n        return ssrRenderingPipeline;\n    }\n    const pipeline = createSSRRenderingPipeline(scene, camera);\n    pipeline.samples = data.samples;\n    pipeline.step = data.step;\n    pipeline.thickness = data.thickness;\n    pipeline.strength = data.strength;\n    pipeline.reflectionSpecularFalloffExponent = data.reflectionSpecularFalloffExponent;\n    pipeline.maxSteps = data.maxSteps;\n    pipeline.maxDistance = data.maxDistance;\n    pipeline.roughnessFactor = data.roughnessFactor;\n    pipeline.reflectivityThreshold = data.reflectivityThreshold;\n    pipeline.blurDispersionStrength = data.blurDispersionStrehgth;\n    pipeline.clipToFrustum = data.clipToFrustum;\n    pipeline.enableSmoothReflections = data.enableSmoothReflections;\n    pipeline.enableAutomaticThicknessComputation = data.enableAutomaticThicknessComputation;\n    pipeline.attenuateFacingCamera = data.attenuateFacingCamera;\n    pipeline.attenuateScreenBorders = data.attenuateScreenBorders;\n    pipeline.attenuateIntersectionDistance = data.attenuateIntersectionDistance;\n    pipeline.attenuateBackfaceReflection = data.attenuateBackfaceReflection;\n    pipeline.blurDownsample = data.blurDownsample;\n    pipeline.selfCollisionNumSkip = data.selfCollisionNumSkip;\n    pipeline.ssrDownsample = data.ssrDownsample;\n    pipeline.backfaceDepthTextureDownsample = data.backfaceDepthTextureDownsample;\n    return pipeline;\n}\n//# sourceMappingURL=ssr.js.map", "import { SSAO2RenderingPipeline } from \"babylonjs\";\nlet ssaoRenderingPipeline = null;\n/**\n * Defines the configuration of the SSAO rendering pipeline per camera.\n */\nexport const ssaoRenderingPipelineCameraConfigurations = new Map();\nexport function getSSAO2RenderingPipeline() {\n    return ssaoRenderingPipeline;\n}\n/**\n * Sets the reference to the SSAO rendering pipeline.\n * @access editor only.\n */\nexport function setSSAO2RenderingPipelineRef(pipeline) {\n    ssaoRenderingPipeline = pipeline;\n}\nexport function disposeSSAO2RenderingPipeline() {\n    if (ssaoRenderingPipeline) {\n        ssaoRenderingPipeline.dispose();\n        ssaoRenderingPipeline = null;\n    }\n}\nexport function createSSAO2RenderingPipeline(scene, camera) {\n    ssaoRenderingPipeline = new SSAO2RenderingPipeline(\"SSAO2RenderingPipeline\", scene, 1.0, [camera]);\n    ssaoRenderingPipeline.samples = 4;\n    return ssaoRenderingPipeline;\n}\nexport function serializeSSAO2RenderingPipeline() {\n    if (!ssaoRenderingPipeline) {\n        return null;\n    }\n    return {\n        radius: ssaoRenderingPipeline.radius,\n        totalStrength: ssaoRenderingPipeline.totalStrength,\n        samples: ssaoRenderingPipeline.samples,\n        maxZ: ssaoRenderingPipeline.maxZ,\n        minZAspect: ssaoRenderingPipeline.minZAspect,\n        epsilon: ssaoRenderingPipeline.epsilon,\n        textureSamples: ssaoRenderingPipeline.textureSamples,\n        bypassBlur: ssaoRenderingPipeline.bypassBlur,\n        bilateralSamples: ssaoRenderingPipeline.bilateralSamples,\n        bilateralSoften: ssaoRenderingPipeline.bilateralSoften,\n        bilateralTolerance: ssaoRenderingPipeline.bilateralTolerance,\n        expensiveBlur: ssaoRenderingPipeline.expensiveBlur,\n    };\n}\nexport function parseSSAO2RenderingPipeline(scene, camera, data) {\n    if (ssaoRenderingPipeline) {\n        return ssaoRenderingPipeline;\n    }\n    const pipeline = createSSAO2RenderingPipeline(scene, camera);\n    pipeline.radius = data.radius;\n    pipeline.totalStrength = data.totalStrength;\n    pipeline.samples = data.samples;\n    pipeline.maxZ = data.maxZ;\n    pipeline.minZAspect = data.minZAspect;\n    pipeline.epsilon = data.epsilon;\n    pipeline.textureSamples = data.textureSamples;\n    pipeline.bypassBlur = data.bypassBlur;\n    pipeline.bilateralSamples = data.bilateralSamples;\n    pipeline.bilateralSoften = data.bilateralSoften;\n    pipeline.bilateralTolerance = data.bilateralTolerance;\n    pipeline.expensiveBlur = data.expensiveBlur;\n    return pipeline;\n}\n//# sourceMappingURL=ssao.js.map", "import { MotionBlurPostProcess } from \"babylonjs\";\nlet motionBlurPostProcess = null;\n/**\n * Defines the configuration of the motion blur post-process per camera.\n */\nexport const motionBlurPostProcessCameraConfigurations = new Map();\nexport function getMotionBlurPostProcess() {\n    return motionBlurPostProcess;\n}\n/**\n * Sets the reference to the motion blur post-process.\n * @access editor only.\n */\nexport function setMotionBlurPostProcessRef(postProcess) {\n    motionBlurPostProcess = postProcess;\n}\nexport function disposeMotionBlurPostProcess() {\n    if (motionBlurPostProcess) {\n        motionBlurPostProcess.dispose();\n        motionBlurPostProcess = null;\n    }\n}\nexport function createMotionBlurPostProcess(scene, camera) {\n    motionBlurPostProcess = new MotionBlurPostProcess(\"MotionBlurPostProcess\", scene, 1.0, camera);\n    motionBlurPostProcess.motionStrength = 1.0;\n    motionBlurPostProcess.isObjectBased = true;\n    return motionBlurPostProcess;\n}\nexport function serializeMotionBlurPostProcess() {\n    if (!motionBlurPostProcess) {\n        return null;\n    }\n    return {\n        isObjectBased: motionBlurPostProcess.isObjectBased,\n        motionStrength: motionBlurPostProcess.motionStrength,\n        motionBlurSamples: motionBlurPostProcess.motionBlurSamples,\n    };\n}\nexport function parseMotionBlurPostProcess(scene, camera, data) {\n    if (motionBlurPostProcess) {\n        return motionBlurPostProcess;\n    }\n    const postProcess = createMotionBlurPostProcess(scene, camera);\n    postProcess.isObjectBased = data.isObjectBased;\n    postProcess.motionStrength = data.motionStrength;\n    postProcess.motionBlurSamples = data.motionBlurSamples;\n    return postProcess;\n}\n//# sourceMappingURL=motion-blur.js.map", "import { Color4 } from \"babylonjs\";\nimport { Vector2 } from \"babylonjs\";\nimport { Texture } from \"babylonjs\";\nimport { ColorGradingTexture } from \"babylonjs\";\nimport { DefaultRenderingPipeline } from \"babylonjs\";\nimport { isTexture } from \"../tools/guards\";\nlet defaultRenderingPipeline = null;\n/**\n * Defines the configuration of the default rendering pipeline per camera.\n */\nexport const defaultPipelineCameraConfigurations = new Map();\n/**\n * Returns the reference to the default rendering pipeline if exists.\n */\nexport function getDefaultRenderingPipeline() {\n    return defaultRenderingPipeline;\n}\n/**\n * Sets the reference to the default rendering pipeline.\n * @access editor only.\n */\nexport function setDefaultRenderingPipelineRef(pipeline) {\n    defaultRenderingPipeline = pipeline;\n}\nexport function disposeDefaultRenderingPipeline() {\n    if (defaultRenderingPipeline) {\n        defaultRenderingPipeline.dispose();\n        defaultRenderingPipeline = null;\n    }\n}\nexport function createDefaultRenderingPipeline(scene, camera) {\n    defaultRenderingPipeline = new DefaultRenderingPipeline(\"DefaultRenderingPipeline\", true, scene, [camera]);\n    defaultRenderingPipeline.samples = 4;\n    defaultRenderingPipeline.depthOfField.lensSize = 512;\n    defaultRenderingPipeline.depthOfField.fStop = 0.25;\n    defaultRenderingPipeline.depthOfField.focusDistance = 55_000;\n    return defaultRenderingPipeline;\n}\nexport function serializeDefaultRenderingPipeline() {\n    if (!defaultRenderingPipeline) {\n        return null;\n    }\n    return {\n        samples: defaultRenderingPipeline.samples,\n        fxaaEnabled: defaultRenderingPipeline.fxaaEnabled,\n        imageProcessingEnabled: defaultRenderingPipeline.imageProcessingEnabled,\n        exposure: defaultRenderingPipeline.imageProcessing?.exposure,\n        contrast: defaultRenderingPipeline.imageProcessing?.contrast,\n        fromLinearSpace: defaultRenderingPipeline.imageProcessing?.fromLinearSpace,\n        toneMappingEnabled: defaultRenderingPipeline.imageProcessing?.toneMappingEnabled,\n        toneMappingType: defaultRenderingPipeline.imageProcessing?.toneMappingType,\n        ditheringEnabled: defaultRenderingPipeline.imageProcessing?.ditheringEnabled,\n        ditheringIntensity: defaultRenderingPipeline.imageProcessing?.ditheringIntensity,\n        bloomEnabled: defaultRenderingPipeline.bloomEnabled,\n        bloomThreshold: defaultRenderingPipeline.bloomThreshold,\n        bloomWeight: defaultRenderingPipeline.bloomWeight,\n        bloomScale: defaultRenderingPipeline.bloomScale,\n        bloomKernel: defaultRenderingPipeline.bloomKernel,\n        sharpenEnabled: defaultRenderingPipeline.sharpenEnabled,\n        sharpenEdgeAmount: defaultRenderingPipeline.sharpen.edgeAmount,\n        sharpenColorAmount: defaultRenderingPipeline.sharpen.colorAmount,\n        grainEnabled: defaultRenderingPipeline.grainEnabled,\n        grainIntensity: defaultRenderingPipeline.grain.intensity,\n        grainAnimated: defaultRenderingPipeline.grain.animated,\n        depthOfFieldEnabled: defaultRenderingPipeline.depthOfFieldEnabled,\n        depthOfFieldBlurLevel: defaultRenderingPipeline.depthOfFieldBlurLevel,\n        lensSize: defaultRenderingPipeline.depthOfField.lensSize,\n        fStop: defaultRenderingPipeline.depthOfField.fStop,\n        focusDistance: defaultRenderingPipeline.depthOfField.focusDistance,\n        focalLength: defaultRenderingPipeline.depthOfField.focalLength,\n        // Since v5.0.0-alpha.9\n        vignetteEnabled: defaultRenderingPipeline.imageProcessing?.vignetteEnabled,\n        vignetteColor: defaultRenderingPipeline.imageProcessing?.vignetteColor.asArray(),\n        vignetteWeight: defaultRenderingPipeline.imageProcessing?.vignetteWeight,\n        chromaticAberrationEnabled: defaultRenderingPipeline.chromaticAberrationEnabled,\n        aberrationAmount: defaultRenderingPipeline.chromaticAberration.aberrationAmount,\n        radialIntensity: defaultRenderingPipeline.chromaticAberration.radialIntensity,\n        direction: defaultRenderingPipeline.chromaticAberration.direction.asArray(),\n        centerPosition: defaultRenderingPipeline.chromaticAberration.centerPosition.asArray(),\n        glowLayerEnabled: defaultRenderingPipeline.glowLayerEnabled,\n        glowLayerIntensity: defaultRenderingPipeline.glowLayer?.intensity,\n        glowLayerBlurKernelSize: defaultRenderingPipeline.glowLayer?.blurKernelSize,\n        // Since v5.0.0-alpha.10\n        colorGradingEnabled: defaultRenderingPipeline.imageProcessing.colorGradingEnabled,\n        colorGradingTexture: defaultRenderingPipeline.imageProcessing.colorGradingTexture?.serialize(),\n        colorGradingWithGreenDepth: defaultRenderingPipeline.imageProcessing.imageProcessingConfiguration.colorGradingWithGreenDepth,\n        colorCurvesEnabled: defaultRenderingPipeline.imageProcessing.colorCurvesEnabled,\n        globalHue: defaultRenderingPipeline.imageProcessing.colorCurves?.globalHue,\n        globalDensity: defaultRenderingPipeline.imageProcessing.colorCurves?.globalDensity,\n        globalExposure: defaultRenderingPipeline.imageProcessing.colorCurves?.globalExposure,\n        globalSaturation: defaultRenderingPipeline.imageProcessing.colorCurves?.globalSaturation,\n        highlightsHue: defaultRenderingPipeline.imageProcessing.colorCurves?.highlightsHue,\n        highlightsDensity: defaultRenderingPipeline.imageProcessing.colorCurves?.highlightsDensity,\n        highlightsExposure: defaultRenderingPipeline.imageProcessing.colorCurves?.highlightsExposure,\n        highlightsSaturation: defaultRenderingPipeline.imageProcessing.colorCurves?.highlightsSaturation,\n        midtonesHue: defaultRenderingPipeline.imageProcessing.colorCurves?.midtonesHue,\n        midtonesDensity: defaultRenderingPipeline.imageProcessing.colorCurves?.midtonesDensity,\n        midtonesExposure: defaultRenderingPipeline.imageProcessing.colorCurves?.midtonesExposure,\n        midtonesSaturation: defaultRenderingPipeline.imageProcessing.colorCurves?.midtonesSaturation,\n        shadowsHue: defaultRenderingPipeline.imageProcessing.colorCurves?.shadowsHue,\n        shadowsDensity: defaultRenderingPipeline.imageProcessing.colorCurves?.shadowsDensity,\n        shadowsExposure: defaultRenderingPipeline.imageProcessing.colorCurves?.shadowsExposure,\n        shadowsSaturation: defaultRenderingPipeline.imageProcessing.colorCurves?.shadowsSaturation,\n    };\n}\nexport function parseDefaultRenderingPipeline(scene, camera, data, rootUrl) {\n    if (defaultRenderingPipeline) {\n        return defaultRenderingPipeline;\n    }\n    const pipeline = createDefaultRenderingPipeline(scene, camera);\n    pipeline.samples = data.samples;\n    pipeline.fxaaEnabled = data.fxaaEnabled;\n    pipeline.imageProcessingEnabled = data.imageProcessingEnabled;\n    if (pipeline.imageProcessing) {\n        pipeline.imageProcessing.exposure = data.exposure;\n        pipeline.imageProcessing.contrast = data.contrast;\n        pipeline.imageProcessing.fromLinearSpace = data.fromLinearSpace;\n        pipeline.imageProcessing.toneMappingEnabled = data.toneMappingEnabled;\n        pipeline.imageProcessing.toneMappingType = data.toneMappingType;\n        pipeline.imageProcessing.ditheringEnabled = data.ditheringEnabled;\n        pipeline.imageProcessing.ditheringIntensity = data.ditheringIntensity;\n        // Since v5.0.0-alpha.9\n        pipeline.imageProcessing.vignetteEnabled = data.vignetteEnabled ?? false;\n        pipeline.imageProcessing.vignetteColor = Color4.FromArray(data.vignetteColor ?? [0, 0, 0]);\n        pipeline.imageProcessing.vignetteWeight = data.vignetteWeight ?? 0.3;\n        // Since v5.0.0-alpha.10\n        pipeline.imageProcessing.colorGradingEnabled = data.colorGradingEnabled ?? false;\n        pipeline.imageProcessing.imageProcessingConfiguration.colorGradingWithGreenDepth = data.colorGradingWithGreenDepth ?? true;\n        if (data.colorGradingTexture) {\n            let texture = null;\n            if (data.colorGradingTexture.customType === \"BABYLON.ColorGradingTexture\") {\n                const absoluteUrl = rootUrl + data.colorGradingTexture.name;\n                texture = new ColorGradingTexture(absoluteUrl, scene);\n                texture.level = data.colorGradingTexture.level;\n            }\n            else {\n                const parsedTexture = Texture.Parse(data.colorGradingTexture, scene, rootUrl);\n                if (isTexture(parsedTexture)) {\n                    texture = parsedTexture;\n                }\n            }\n            pipeline.imageProcessing.colorGradingTexture = texture;\n        }\n        pipeline.imageProcessing.colorCurvesEnabled = data.colorCurvesEnabled ?? false;\n        if (pipeline.imageProcessing.colorCurves) {\n            pipeline.imageProcessing.colorCurves.globalHue = data.globalHue ?? 30;\n            pipeline.imageProcessing.colorCurves.globalDensity = data.globalDensity ?? 0;\n            pipeline.imageProcessing.colorCurves.globalExposure = data.globalExposure ?? 0;\n            pipeline.imageProcessing.colorCurves.globalSaturation = data.globalSaturation ?? 0;\n            pipeline.imageProcessing.colorCurves.highlightsHue = data.highlightsHue ?? 30;\n            pipeline.imageProcessing.colorCurves.highlightsDensity = data.highlightsDensity ?? 0;\n            pipeline.imageProcessing.colorCurves.highlightsExposure = data.highlightsExposure ?? 0;\n            pipeline.imageProcessing.colorCurves.highlightsSaturation = data.highlightsSaturation ?? 0;\n            pipeline.imageProcessing.colorCurves.midtonesHue = data.midtonesHue ?? 30;\n            pipeline.imageProcessing.colorCurves.midtonesDensity = data.midtonesDensity ?? 0;\n            pipeline.imageProcessing.colorCurves.midtonesExposure = data.midtonesExposure ?? 0;\n            pipeline.imageProcessing.colorCurves.midtonesSaturation = data.midtonesSaturation ?? 0;\n            pipeline.imageProcessing.colorCurves.shadowsHue = data.shadowsHue ?? 30;\n            pipeline.imageProcessing.colorCurves.shadowsDensity = data.shadowsDensity ?? 0;\n            pipeline.imageProcessing.colorCurves.shadowsExposure = data.shadowsExposure ?? 0;\n            pipeline.imageProcessing.colorCurves.shadowsSaturation = data.shadowsSaturation ?? 0;\n        }\n    }\n    pipeline.bloomEnabled = data.bloomEnabled;\n    pipeline.bloomThreshold = data.bloomThreshold;\n    pipeline.bloomWeight = data.bloomWeight;\n    pipeline.bloomScale = data.bloomScale;\n    pipeline.bloomKernel = data.bloomKernel;\n    pipeline.sharpenEnabled = data.sharpenEnabled;\n    pipeline.sharpen.edgeAmount = data.sharpenEdgeAmount;\n    pipeline.sharpen.colorAmount = data.sharpenColorAmount;\n    pipeline.grainEnabled = data.grainEnabled;\n    pipeline.grain.intensity = data.grainIntensity;\n    pipeline.grain.animated = data.grainAnimated;\n    pipeline.depthOfFieldEnabled = data.depthOfFieldEnabled;\n    pipeline.depthOfFieldBlurLevel = data.depthOfFieldBlurLevel;\n    pipeline.depthOfField.lensSize = data.lensSize;\n    pipeline.depthOfField.fStop = data.fStop;\n    pipeline.depthOfField.focusDistance = data.focusDistance;\n    pipeline.depthOfField.focalLength = data.focalLength;\n    // Since v5.0.0-alpha.9\n    pipeline.chromaticAberrationEnabled = data.chromaticAberrationEnabled ?? false;\n    pipeline.chromaticAberration.aberrationAmount = data.aberrationAmount ?? 10;\n    pipeline.chromaticAberration.radialIntensity = data.radialIntensity ?? 1;\n    pipeline.chromaticAberration.direction = Vector2.FromArray(data.direction ?? [0, 0]);\n    pipeline.chromaticAberration.centerPosition = Vector2.FromArray(data.centerPosition ?? [0, 0]);\n    pipeline.glowLayerEnabled = data.glowLayerEnabled ?? false;\n    if (pipeline.glowLayer) {\n        pipeline.glowLayer.intensity = data.glowLayerIntensity ?? 1;\n        pipeline.glowLayer.blurKernelSize = data.glowLayerBlurKernelSize ?? 32;\n    }\n    return pipeline;\n}\n//# sourceMappingURL=default-pipeline.js.map", "import { vlsPostProcessCameraConfigurations } from \"../rendering/vls\";\nimport { ssrRenderingPipelineCameraConfigurations } from \"../rendering/ssr\";\nimport { ssaoRenderingPipelineCameraConfigurations } from \"../rendering/ssao\";\nimport { motionBlurPostProcessCameraConfigurations } from \"../rendering/motion-blur\";\nimport { defaultPipelineCameraConfigurations } from \"../rendering/default-pipeline\";\nexport function applyRenderingConfigurations(scene, rendering) {\n    const postProcessConfigurations = Array.isArray(rendering) ? rendering : [];\n    postProcessConfigurations.forEach((configuration) => {\n        const camera = scene.getCameraById(configuration.cameraId);\n        if (!camera) {\n            return;\n        }\n        if (configuration.ssao2RenderingPipeline) {\n            ssaoRenderingPipelineCameraConfigurations.set(camera, configuration.ssao2RenderingPipeline);\n        }\n        if (configuration.vlsPostProcess) {\n            vlsPostProcessCameraConfigurations.set(camera, configuration.vlsPostProcess);\n        }\n        if (configuration.ssrRenderingPipeline) {\n            ssrRenderingPipelineCameraConfigurations.set(camera, configuration.ssrRenderingPipeline);\n        }\n        if (configuration.motionBlurPostProcess) {\n            motionBlurPostProcessCameraConfigurations.set(camera, configuration.motionBlurPostProcess);\n        }\n        if (configuration.defaultRenderingPipeline) {\n            defaultPipelineCameraConfigurations.set(camera, configuration.defaultRenderingPipeline);\n        }\n    });\n}\n//# sourceMappingURL=rendering.js.map", "import { disposeVLSPostProcess, parseVLSPostProcess, serializeVLSPostProcess, vlsPostProcessCameraConfigurations } from \"./vls\";\nimport { disposeSSRRenderingPipeline, parseSSRRenderingPipeline, serializeSSRRenderingPipeline, ssrRenderingPipelineCameraConfigurations } from \"./ssr\";\nimport { disposeSSAO2RenderingPipeline, parseSSAO2RenderingPipeline, serializeSSAO2RenderingPipeline, ssaoRenderingPipelineCameraConfigurations } from \"./ssao\";\nimport { disposeMotionBlurPostProcess, motionBlurPostProcessCameraConfigurations, parseMotionBlurPostProcess, serializeMotionBlurPostProcess } from \"./motion-blur\";\nimport { defaultPipelineCameraConfigurations, disposeDefaultRenderingPipeline, parseDefaultRenderingPipeline, serializeDefaultRenderingPipeline } from \"./default-pipeline\";\n/**\n * Saves the rendering configurations for the given camera. This is useful to restore the rendering configurations\n * when the camera is re-activated (typically using the preview panel toolbar).\n * @param camera defines the reference to the camera to save its rendering configurations.\n */\nexport function saveRenderingConfigurationForCamera(camera) {\n    ssaoRenderingPipelineCameraConfigurations.set(camera, serializeSSAO2RenderingPipeline());\n    vlsPostProcessCameraConfigurations.set(camera, serializeVLSPostProcess());\n    ssrRenderingPipelineCameraConfigurations.set(camera, serializeSSRRenderingPipeline());\n    motionBlurPostProcessCameraConfigurations.set(camera, serializeMotionBlurPostProcess());\n    defaultPipelineCameraConfigurations.set(camera, serializeDefaultRenderingPipeline());\n}\n/**\n * Applies the post-processes configurations for the given camera. Rendering configurations (motion blur, ssao, etc.) are\n * saved per-camera and can be applied on demand using this function.\n * Previous post-processes configurations are disposed before applying the new ones.\n * @param camera defines the reference to the camera to apply its rendering configurations.\n * @param rootUrl defines the rootUrl that contains all resource files needed by the post-processes (color grading texture, etc.).\n */\nexport function applyRenderingConfigurationForCamera(camera, rootUrl) {\n    disposeSSAO2RenderingPipeline();\n    disposeVLSPostProcess(camera.getScene());\n    disposeSSRRenderingPipeline();\n    disposeMotionBlurPostProcess();\n    disposeDefaultRenderingPipeline();\n    const ssao2RenderingPipeline = ssaoRenderingPipelineCameraConfigurations.get(camera);\n    if (ssao2RenderingPipeline) {\n        parseSSAO2RenderingPipeline(camera.getScene(), camera, ssao2RenderingPipeline);\n    }\n    const vlsPostProcess = vlsPostProcessCameraConfigurations.get(camera);\n    if (vlsPostProcess) {\n        parseVLSPostProcess(camera.getScene(), vlsPostProcess);\n    }\n    const ssrRenderingPipeline = ssrRenderingPipelineCameraConfigurations.get(camera);\n    if (ssrRenderingPipeline) {\n        parseSSRRenderingPipeline(camera.getScene(), camera, ssrRenderingPipeline);\n    }\n    const motionBlurPostProcess = motionBlurPostProcessCameraConfigurations.get(camera);\n    if (motionBlurPostProcess) {\n        parseMotionBlurPostProcess(camera.getScene(), camera, motionBlurPostProcess);\n    }\n    const defaultRenderingPipeline = defaultPipelineCameraConfigurations.get(camera);\n    if (defaultRenderingPipeline) {\n        parseDefaultRenderingPipeline(camera.getScene(), camera, defaultRenderingPipeline, rootUrl);\n    }\n}\n//# sourceMappingURL=tools.js.map", "import { Vector3 } from \"babylonjs\";\nimport { RenderTargetTexture } from \"babylonjs\";\nexport function configureShadowMapRenderListPredicate(scene) {\n    scene.lights.forEach((light) => {\n        const shadowMap = light.getShadowGenerator()?.getShadowMap();\n        if (!shadowMap) {\n            return;\n        }\n        shadowMap.renderListPredicate = (mesh) => {\n            const distance = Vector3.Distance(mesh.getAbsolutePosition(), light.getAbsolutePosition());\n            return distance <= light.range;\n        };\n    });\n}\nexport async function configureShadowMapRefreshRate(scene) {\n    scene.executeWhenReady(() => {\n        scene.lights.forEach((light) => {\n            const shadowMap = light.getShadowGenerator()?.getShadowMap();\n            if (shadowMap) {\n                shadowMap.refreshRate = light.metadata?.refreshRate ?? RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;\n            }\n        });\n    });\n}\n//# sourceMappingURL=light.js.map", "import { SceneComponentConstants } from \"babylonjs\";\nimport { GetParser, AddParser } from \"babylonjs\";\nconst audioParser = GetParser(SceneComponentConstants.NAME_AUDIO);\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData, scene, container, rootUrl) => {\n    audioParser?.(parsedData, scene, container, rootUrl);\n    parsedData.sounds?.forEach((sound) => {\n        const instance = container.sounds?.find((s) => s.name === sound.name);\n        if (instance) {\n            instance.id = sound.id;\n            instance.uniqueId = sound.uniqueId;\n        }\n    });\n});\n//# sourceMappingURL=sound.js.map", "import { SerializationHelper } from \"babylonjs\";\nimport { getPowerOfTwoUntil } from \"../tools/scalar\";\n/**\n * Defines the reference to the original texture parser function.\n */\nconst textureParser = SerializationHelper._TextureParser;\nSerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {\n    if (scene.loadingQuality === \"high\" || !sourceProperty.metadata?.baseSize) {\n        return textureParser(sourceProperty, scene, rootUrl);\n    }\n    const width = sourceProperty.metadata.baseSize.width;\n    const height = sourceProperty.metadata.baseSize.height;\n    const isPowerOfTwo = width === getPowerOfTwoUntil(width) || height === getPowerOfTwoUntil(height);\n    let suffix = \"\";\n    switch (scene.loadingQuality) {\n        case \"medium\":\n            let midWidth = (width * 0.66) >> 0;\n            let midHeight = (height * 0.66) >> 0;\n            if (isPowerOfTwo) {\n                midWidth = getPowerOfTwoUntil(midWidth);\n                midHeight = getPowerOfTwoUntil(midHeight);\n            }\n            suffix = `_${midWidth}_${midHeight}`;\n            break;\n        case \"low\":\n            let lowWidth = (width * 0.33) >> 0;\n            let lowHeight = (height * 0.33) >> 0;\n            if (isPowerOfTwo) {\n                lowWidth = getPowerOfTwoUntil(lowWidth);\n                lowHeight = getPowerOfTwoUntil(lowHeight);\n            }\n            suffix = `_${lowWidth}_${lowHeight}`;\n            break;\n    }\n    const name = sourceProperty.name;\n    if (!name || !suffix) {\n        return textureParser(sourceProperty, scene, rootUrl);\n    }\n    const finalUrl = name.split(\"/\");\n    const filename = finalUrl.pop();\n    if (!filename) {\n        return textureParser(sourceProperty, scene, rootUrl);\n    }\n    const extension = filename.split(\".\").pop();\n    const baseFilename = filename.replace(`.${extension}`, \"\");\n    const newFilename = `${baseFilename}${suffix}.${extension}`;\n    finalUrl.push(newFilename);\n    sourceProperty.name = finalUrl.join(\"/\");\n    return textureParser(sourceProperty, scene, rootUrl);\n};\n//# sourceMappingURL=texture.js.map", "export function getPowerOfTwoUntil(limit) {\n    let size = 1;\n    while (size <= limit) {\n        size <<= 1;\n    }\n    return size >> 1;\n}\n//# sourceMappingURL=scalar.js.map", "import { Tools } from \"babylonjs\";\nimport { isInstancedMesh } from \"../tools/guards\";\n/**\n * Loads the file located at `rootUrl + relativePath` and creates a new material from it.\n * @param rootUrl defines the absolute root url for the assets. (generally \"/scene/\")\n * @param relativePath defines the path relative to `rootUrl` for the material file\n * @param scene defines the reference to the scene where to add the loaded material.\n * @returns the reference to the created material.\n * @example await loadMaterialFromFile<PBRMaterial>(\"/scene/\", \"assets/floor.material\", scene);\n */\nexport async function loadMaterialFromFile(rootUrl, relativePath, scene) {\n    const response = await fetch(rootUrl + relativePath);\n    const data = await response.json();\n    const ctor = Tools.Instantiate(data.customType);\n    const material = ctor.Parse(data, scene, rootUrl);\n    material.id = data.id;\n    material.uniqueId = data.uniqueId;\n    return material;\n}\n/**\n * Force compile all materials of the given scene.\n * This is useful to ensure that all materials are compiled and ready to use to avoid lag.\n * @param scene The scene to force compile all materials\n */\nexport function forceCompileAllSceneMaterials(scene) {\n    return Promise.all(scene.materials.map(async (material) => {\n        const meshes = material.getBindedMeshes();\n        await Promise.all(meshes.map(async (mesh) => {\n            if (isInstancedMesh(mesh)) {\n                return;\n            }\n            await material.forceCompilationAsync(mesh, {\n                clipPlane: !!scene.clipPlane,\n                useInstances: mesh.hasInstances,\n            });\n        }));\n    }));\n}\n//# sourceMappingURL=material.js.map", "import { Animation } from \"babylonjs\";\n/**\n * Returns the animation type according to the given animated property type.\n * @param effectiveProperty defines the reference to the animated property to get its animation type.\n */\nexport function getAnimationTypeForObject(effectiveProperty) {\n    if (!isNaN(parseFloat(effectiveProperty)) && isFinite(effectiveProperty)) {\n        return Animation.ANIMATIONTYPE_FLOAT;\n    }\n    switch (effectiveProperty?.getClassName?.()) {\n        case \"Vector2\": return Animation.ANIMATIONTYPE_VECTOR2;\n        case \"Vector3\": return Animation.ANIMATIONTYPE_VECTOR3;\n        case \"Quaternion\": return Animation.ANIMATIONTYPE_QUATERNION;\n        case \"Color3\": return Animation.ANIMATIONTYPE_COLOR3;\n        case \"Color4\": return Animation.ANIMATIONTYPE_COLOR4;\n        case \"Size\": return Animation.ANIMATIONTYPE_SIZE;\n        case \"Matrix\": return Animation.ANIMATIONTYPE_MATRIX;\n    }\n    return null;\n}\n//# sourceMappingURL=animation.js.map", "/**\n * Makes the decorated property visible in the editor inspector as a boolean.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (description, etc.).\n */\nexport function visibleAsBoolean(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"boolean\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a string.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (description, etc.).\n */\nexport function visibleAsString(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"string\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a number.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (min, max, etc.).\n */\nexport function visibleAsNumber(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"number\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a vector2.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (min, max, etc.).\n */\nexport function visibleAsVector2(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"vector2\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a vector3.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (min, max, etc.).\n */\nexport function visibleAsVector3(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"vector3\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a color3.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (min, max, etc.).\n */\nexport function visibleAsColor3(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"color3\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a color4.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (min, max, etc.).\n */\nexport function visibleAsColor4(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"color4\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as an entity.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param entityType defines the type of entity to be displayed in the inspector (node, sound, animationGroup or particleSystem).\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (min, max, etc.).\n */\nexport function visibleAsEntity(entityType, label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                entityType,\n                type: \"entity\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a Texture.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (accept cubes, etc.).\n */\nexport function visibleAsTexture(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"texture\",\n            },\n        });\n    };\n}\n/**\n * Makes the decorated property visible in the editor inspector as a KeyMap.\n * The property can be customized per object in the editor and the custom value is applied\n * once the script is invoked at runtime in the game/application.\n * This can be used only by scripts using Classes.\n * @param label defines the optional label displayed in the inspector in the editor.\n * @param configuration defines the optional configuration for the field in the inspector (description, etc.).\n */\nexport function visibleAsKeyMap(label, configuration) {\n    return function (target, propertyKey) {\n        const ctor = target.constructor;\n        ctor._VisibleInInspector ??= [];\n        ctor._VisibleInInspector.push({\n            label,\n            propertyKey,\n            configuration: {\n                ...configuration,\n                type: \"keymap\",\n            },\n        });\n    };\n}\n//# sourceMappingURL=inspector.js.map", "import { Animation } from \"babylonjs\";\nimport { Color3, Color4 } from \"babylonjs\";\nimport { Quaternion, Vector2, Vector3, Matrix } from \"babylonjs\";\nimport { getDefaultRenderingPipeline } from \"../rendering/default-pipeline\";\nimport { getSoundById } from \"../tools/sound\";\nimport { getAnimationTypeForObject } from \"../tools/animation\";\nimport { getPropertyValue } from \"./tools\";\n/**\n * Parses the given JSON data and returns a new cinematic object.\n * @param data defines the JSON data of the cinematic to parse.\n * @param scene defines the reference to the scene used to retrieve cinematic's data.\n */\nexport function parseCinematic(data, scene) {\n    return {\n        name: data.name,\n        framesPerSecond: data.framesPerSecond,\n        outputFramesPerSecond: data.outputFramesPerSecond,\n        tracks: data.tracks.map((track) => {\n            let node = null;\n            let animationType = null;\n            if (track.node) {\n                node = scene.getNodeById(track.node);\n                if (!node) {\n                    node = scene.particleSystems?.find((ps) => ps.id === track.node) ?? null;\n                }\n            }\n            else if (track.defaultRenderingPipeline) {\n                node = getDefaultRenderingPipeline();\n            }\n            if (track.propertyPath) {\n                const value = getPropertyValue(node, track.propertyPath);\n                animationType = getAnimationTypeForObject(value);\n            }\n            let sound = null;\n            if (track.sound) {\n                sound = getSoundById(track.sound, scene);\n            }\n            return {\n                node,\n                sound,\n                propertyPath: track.propertyPath,\n                defaultRenderingPipeline: track.defaultRenderingPipeline,\n                animationGroup: track.animationGroup ? scene.getAnimationGroupByName(track.animationGroup) : null,\n                animationGroups: track.animationGroups,\n                sounds: track.sounds,\n                keyFrameEvents: track.keyFrameEvents?.map((event) => {\n                    const result = {\n                        ...event,\n                    };\n                    switch (event.data?.type) {\n                        case \"set-enabled\":\n                            result.data = {\n                                type: \"set-enabled\",\n                                value: event.data.value,\n                                node: scene.getNodeById(event.data.node),\n                            };\n                            break;\n                        case \"apply-impulse\":\n                            result.data = {\n                                type: \"apply-impulse\",\n                                radius: event.data.radius,\n                                mesh: scene.getMeshById(event.data.mesh),\n                                force: Vector3.FromArray(event.data.force),\n                                contactPoint: Vector3.FromArray(event.data.contactPoint),\n                            };\n                            break;\n                    }\n                    return result;\n                }),\n                keyFrameAnimations: node && animationType !== null && track.keyFrameAnimations?.map((keyFrame) => {\n                    const animationKey = keyFrame.type === \"key\" ? keyFrame : null;\n                    if (animationKey) {\n                        return {\n                            ...animationKey,\n                            value: parseCinematicKeyValue(animationKey.value, animationType),\n                            inTangent: parseCinematicKeyValue(animationKey.inTangent, animationType),\n                            outTangent: parseCinematicKeyValue(animationKey.outTangent, animationType),\n                        };\n                    }\n                    const animationKeyCut = keyFrame.type === \"cut\" ? keyFrame : null;\n                    if (animationKeyCut) {\n                        return {\n                            ...animationKeyCut,\n                            key1: {\n                                ...animationKeyCut.key1,\n                                value: parseCinematicKeyValue(animationKeyCut.key1.value, animationType),\n                                inTangent: parseCinematicKeyValue(animationKeyCut.key1.inTangent, animationType),\n                                outTangent: parseCinematicKeyValue(animationKeyCut.key1.outTangent, animationType),\n                            },\n                            key2: {\n                                ...animationKeyCut.key2,\n                                value: parseCinematicKeyValue(animationKeyCut.key2.value, animationType),\n                                inTangent: parseCinematicKeyValue(animationKeyCut.key2.inTangent, animationType),\n                                outTangent: parseCinematicKeyValue(animationKeyCut.key2.outTangent, animationType),\n                            },\n                        };\n                    }\n                    throw new Error(`Unknown key frame type: ${keyFrame.type}`);\n                }),\n            };\n        }),\n    };\n}\n/**\n * Parses the given value and returns the reference to the right value to be animated.\n * @param value defines the raw value to parse (ie. number or array for vectors).\n * @param type defines the type of the property animated.\n * @example [0, 0, 0] with type Animation.ANIMATIONTYPE_VECTOR3 will return a new Vector3(0, 0, 0) object.\n */\nexport function parseCinematicKeyValue(value, type) {\n    if (value === null) {\n        return null;\n    }\n    if (value === undefined) {\n        return undefined;\n    }\n    switch (type) {\n        case Animation.ANIMATIONTYPE_FLOAT: return value;\n        case Animation.ANIMATIONTYPE_VECTOR2: return Vector2.FromArray(value);\n        case Animation.ANIMATIONTYPE_VECTOR3: return Vector3.FromArray(value);\n        case Animation.ANIMATIONTYPE_QUATERNION: return Quaternion.FromArray(value);\n        case Animation.ANIMATIONTYPE_COLOR3: return Color3.FromArray(value);\n        case Animation.ANIMATIONTYPE_COLOR4: return Color4.FromArray(value);\n        case Animation.ANIMATIONTYPE_MATRIX: return Matrix.FromArray(value);\n    }\n}\n//# sourceMappingURL=parse.js.map", "import { Animation } from \"babylonjs\";\nexport function cloneKey(dataType, key) {\n    let value;\n    switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n            value = key.value;\n            break;\n        default:\n            value = key.value.clone();\n            break;\n    }\n    return {\n        value,\n        frame: key.frame,\n        interpolation: key.interpolation,\n        inTangent: dataType === Animation.ANIMATIONTYPE_FLOAT ? key.inTangent : key.inTangent?.clone(),\n        outTangent: dataType === Animation.ANIMATIONTYPE_FLOAT ? key.outTangent : key.outTangent?.clone(),\n    };\n}\n/**\n * Returns the current value of the given property of the given object.\n * @param object defines the root object where to parse the property and return its value.\n * @param property defines the path of the property to get its value.\n * @example getPropertyValue(scene, \"ambientColor\");\n * @example getPropertyValue(scene, \"ambientColor.r\");\n */\nexport function getPropertyValue(object, property) {\n    const parts = property.split('.');\n    let value = object;\n    for (let i = 0; i < parts.length; ++i) {\n        value = value[parts[i]];\n    }\n    return value;\n}\n//# sourceMappingURL=tools.js.map", "import { Tools } from \"babylonjs\";\nimport { Animation } from \"babylonjs\";\nimport { AnimationEvent } from \"babylonjs\";\nimport { AnimationGroup } from \"babylonjs\";\nimport { isCamera } from \"../tools/guards\";\nimport { getAnimationTypeForObject } from \"../tools/animation\";\nimport { getMotionBlurPostProcess } from \"../rendering/motion-blur\";\nimport { getDefaultRenderingPipeline } from \"../rendering/default-pipeline\";\nimport { handleSetEnabledEvent } from \"./events/set-enabled\";\nimport { handleApplyImpulseEvent } from \"./events/apply-impulse\";\nimport { cloneKey, getPropertyValue } from \"./tools\";\n/**\n * Parses the given cinematic object and generates a new playable animation group.\n * @param cinematic defines the cinematic object to parse that was previously loaded.\n * @param scene defines the reference to the scene where to retrieve the animated objects.\n * @param options defines the options to use when generating the animation group.\n */\nexport function generateCinematicAnimationGroup(cinematic, scene, options) {\n    const result = new AnimationGroup(cinematic.name, scene);\n    cinematic.tracks.forEach((track) => {\n        // Animation groups\n        const animationGroup = track.animationGroup;\n        if (animationGroup) {\n            track.animationGroups?.forEach((configuration) => {\n                animationGroup.targetedAnimations.forEach((targetedAnimation) => {\n                    let animation = null;\n                    defer: {\n                        const existingTargetedAnimations = result.targetedAnimations.filter((ta2) => ta2.target === targetedAnimation.target);\n                        if (existingTargetedAnimations.length) {\n                            const existingTargetedAnimationsPair = existingTargetedAnimations.find((et) => et.animation.targetProperty === targetedAnimation.animation.targetProperty);\n                            if (existingTargetedAnimationsPair) {\n                                animation = existingTargetedAnimationsPair.animation;\n                                break defer;\n                            }\n                        }\n                        animation = targetedAnimation.animation.clone();\n                        animation.setKeys([]);\n                        animation.name = Tools.RandomId();\n                        animation.framePerSecond = cinematic.framesPerSecond;\n                    }\n                    const keys = animation.getKeys();\n                    const sourceKeys = targetedAnimation.animation.getKeys();\n                    const speed = configuration.speed;\n                    const normalizedFps = (cinematic.framesPerSecond / targetedAnimation.animation.framePerSecond) / speed;\n                    sourceKeys.forEach((k) => {\n                        if (k.frame >= configuration.startFrame && k.frame <= configuration.endFrame) {\n                            keys.push({\n                                ...cloneKey(targetedAnimation.animation.dataType, k),\n                                frame: configuration.frame + k.frame * normalizedFps,\n                            });\n                        }\n                    });\n                    animation.setKeys(keys);\n                    result.addTargetedAnimation(animation, targetedAnimation.target);\n                });\n            });\n        }\n        const sound = track.sound;\n        const soundBuffer = sound?.getAudioBuffer();\n        if (!options?.ignoreSounds && sound && soundBuffer && track.sounds?.length) {\n            const dummyObject = {\n                dummy: 0,\n            };\n            const soundAnimation = new Animation(sound.name, \"dummy\", 60, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE, false);\n            let maxFrame = 0;\n            track.sounds?.forEach((configuration) => {\n                const duration = configuration.endFrame - configuration.startFrame;\n                maxFrame = Math.max(maxFrame, configuration.frame + duration);\n                soundAnimation.addEvent(new AnimationEvent(configuration.frame, (currentFrame) => {\n                    const frameDiff = currentFrame - configuration.frame;\n                    const offset = (frameDiff + configuration.startFrame) / cinematic.framesPerSecond;\n                    // sound.stop();\n                    sound.play(0, offset);\n                }, false));\n                soundAnimation.addEvent(new AnimationEvent(configuration.frame + duration, () => {\n                    sound.stop();\n                }));\n            });\n            soundAnimation.setKeys([\n                { frame: 0, value: 0 },\n                { frame: maxFrame, value: maxFrame },\n            ]);\n            result.addTargetedAnimation(soundAnimation, dummyObject);\n        }\n        if (track.keyFrameEvents) {\n            const dummyObject = {\n                dummy: 0,\n            };\n            const eventsAnimation = new Animation(\"events\", \"dummy\", 60, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE, false);\n            let maxFrame = 0;\n            track.keyFrameEvents?.forEach((configuration) => {\n                maxFrame = Math.max(maxFrame, configuration.frame);\n                eventsAnimation.addEvent(new AnimationEvent(configuration.frame, () => {\n                    switch (configuration.data?.type) {\n                        case \"set-enabled\":\n                            handleSetEnabledEvent(configuration.data);\n                            break;\n                        case \"apply-impulse\":\n                            handleApplyImpulseEvent(scene, configuration.data);\n                            break;\n                    }\n                }));\n            });\n            eventsAnimation.setKeys([\n                { frame: 0, value: 0 },\n                { frame: maxFrame, value: maxFrame },\n            ]);\n            result.addTargetedAnimation(eventsAnimation, dummyObject);\n        }\n        const node = track.defaultRenderingPipeline ? getDefaultRenderingPipeline() : track.node;\n        if (!node || !track.propertyPath || !track.keyFrameAnimations) {\n            return;\n        }\n        const value = getPropertyValue(node, track.propertyPath);\n        const animationType = getAnimationTypeForObject(value);\n        if (animationType === null) {\n            return;\n        }\n        const animation = new Animation(track.propertyPath, track.propertyPath, 60, animationType, Animation.ANIMATIONLOOPMODE_CYCLE, false);\n        const keys = [];\n        track.keyFrameAnimations?.forEach((keyFrame) => {\n            const animationKey = keyFrame.type === \"key\" ? keyFrame : null;\n            if (animationKey) {\n                return keys.push(animationKey);\n            }\n            const animationKeyCut = keyFrame.type === \"cut\" ? keyFrame : null;\n            if (animationKeyCut) {\n                keys.push(animationKeyCut.key1);\n                keys.push(animationKeyCut.key2);\n                if (isCamera(node) && track.propertyPath === \"position\") {\n                    animation.addEvent(new AnimationEvent(animationKeyCut.key1.frame, () => {\n                        const motionBlur = getMotionBlurPostProcess();\n                        if (!motionBlur) {\n                            return;\n                        }\n                        let motionStrength = motionBlur.motionStrength;\n                        motionBlur.motionStrength = 0;\n                        requestAnimationFrame(() => {\n                            motionBlur.motionStrength = motionStrength;\n                        });\n                    }));\n                }\n            }\n        });\n        animation.setKeys(keys);\n        result.addTargetedAnimation(animation, node);\n    });\n    result.normalize();\n    return result;\n}\n//# sourceMappingURL=generate.js.map", "import { Vector3 } from \"babylonjs\";\nconst zeroVector = Vector3.Zero();\nexport function handleApplyImpulseEvent(scene, config) {\n    let meshes = config.mesh\n        ? [config.mesh]\n        : scene.meshes.filter((m) => m.physicsAggregate);\n    if (config.radius) {\n        meshes = meshes.filter((mesh) => {\n            const centerWorld = mesh.getBoundingInfo().boundingBox.centerWorld;\n            return Vector3.Distance(centerWorld, config.contactPoint) <= config.radius;\n        });\n    }\n    meshes.forEach((mesh) => {\n        if (mesh.physicsAggregate?.body) {\n            const direction = config.contactPoint.subtract(mesh.getBoundingInfo().boundingBox.centerWorld);\n            direction.multiplyInPlace(config.force);\n            mesh.physicsAggregate.body.setLinearVelocity(zeroVector);\n            mesh.physicsAggregate.body.setAngularVelocity(zeroVector);\n            mesh.physicsAggregate.body.applyImpulse(direction.negateInPlace(), config.contactPoint);\n        }\n    });\n}\n//# sourceMappingURL=apply-impulse.js.map", "import { Mesh } from \"babylonjs\";\n\nimport { IScript, visibleAsNumber } from \"babylonjs-editor-tools\";\n\nexport default class SceneComponent implements IScript {\n    @visibleAsNumber(\"Speed\", {\n    \tmin: 0,\n    \tmax: 0.1,\n    })\n\tprivate _speed: number = 0.04;\n\n    public constructor(public mesh: Mesh) { }\n\n    public onStart(): void {\n\n    }\n\n    public onUpdate(): void {\n    \tthis.mesh.rotation.y += this._speed * this.mesh.getScene().getAnimationRatio();\n    }\n} \n"],
  "mappings": "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",
  "names": ["import_babylonjs", "import_babylonjs", "particleSystem", "scriptsMap", "exports", "import_babylonjs", "import_babylonjs", "mesh", "vlsPostProcess", "import_babylonjs", "import_babylonjs", "import_babylonjs", "import_babylonjs", "vlsPostProcess", "ssrRenderingPipeline", "motionBlurPostProcess", "defaultRenderingPipeline", "import_babylonjs", "import_babylonjs", "import_babylonjs", "scriptsMap", "import_babylonjs", "import_babylonjs", "import_babylonjs", "import_babylonjs", "import_babylonjs", "import_babylonjs"]
}
