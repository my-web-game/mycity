import { Vector3 } from "@babylonjs/core/Maths/math.vector";
import { Constants } from "@babylonjs/core/Engines/constants";
import { AppendSceneAsync } from "@babylonjs/core/Loading/sceneLoader";
import { SceneLoaderFlags } from "@babylonjs/core/Loading/sceneLoaderFlags";
import { isMesh } from "../tools/guards";
import { _applyScriptsForObject } from "./script";
import { configurePhysicsAggregate } from "./physics";
import { applyRenderingConfigurations } from "./rendering";
import { applyRenderingConfigurationForCamera } from "../rendering/tools";
import { configureShadowMapRefreshRate, configureShadowMapRenderListPredicate } from "../tools/light";
import "./sound";
import "./texture";
export async function loadScene(rootUrl, sceneFilename, scene, scriptsMap, options) {
    scene.loadingQuality = options?.quality ?? "high";
    await AppendSceneAsync(`${rootUrl}${sceneFilename}`, scene, {
        pluginExtension: ".babylon",
        onProgress: (event) => {
            const progress = Math.min((event.loaded / event.total) * 0.5);
            options?.onProgress?.(progress);
        },
    });
    // Ensure all meshes perform their delay state check
    if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
        scene.meshes.forEach((m) => isMesh(m) && m._checkDelayState());
    }
    const waitingItemsCount = scene.getWaitingItemsCount();
    // Wait until scene is ready.
    while (!scene.isDisposed && (!scene.isReady() || scene.getWaitingItemsCount() > 0)) {
        await new Promise((resolve) => setTimeout(resolve, 150));
        const loadedItemsCount = waitingItemsCount - scene.getWaitingItemsCount();
        if (loadedItemsCount === waitingItemsCount) {
            scene.textures.forEach((texture) => {
                if (texture.delayLoadState === Constants.DELAYLOADSTATE_NONE) {
                    texture.delayLoadState = Constants.DELAYLOADSTATE_LOADED;
                }
            });
        }
        options?.onProgress?.(0.5 + (loadedItemsCount / waitingItemsCount) * 0.5);
    }
    options?.onProgress?.(1);
    configureShadowMapRenderListPredicate(scene);
    configureShadowMapRefreshRate(scene);
    if (scene.metadata?.rendering) {
        applyRenderingConfigurations(scene, scene.metadata.rendering);
        if (scene.activeCamera) {
            applyRenderingConfigurationForCamera(scene.activeCamera, rootUrl);
        }
    }
    if (scene.metadata?.physicsGravity) {
        scene.getPhysicsEngine()?.setGravity(Vector3.FromArray(scene.metadata?.physicsGravity));
    }
    _applyScriptsForObject(scene, scene, scriptsMap, rootUrl);
    scene.transformNodes.forEach((transformNode) => {
        _applyScriptsForObject(scene, transformNode, scriptsMap, rootUrl);
    });
    scene.meshes.forEach((mesh) => {
        configurePhysicsAggregate(mesh);
        _applyScriptsForObject(scene, mesh, scriptsMap, rootUrl);
    });
    scene.lights.forEach((light) => {
        _applyScriptsForObject(scene, light, scriptsMap, rootUrl);
    });
    scene.cameras.forEach((camera) => {
        _applyScriptsForObject(scene, camera, scriptsMap, rootUrl);
    });
}
//# sourceMappingURL=loader.js.map